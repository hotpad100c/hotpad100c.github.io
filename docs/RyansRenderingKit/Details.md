---
permalink: /RyansRenderingKit/Details/
---
# 概念与原理

> 本篇文档记录本库的目的，概念与实现详细。以方便日后维护的进行。



## 核心概念
- 形状 (Shape)
> 最基本的单元。此库中所有可渲染的对象都是 Shape 的子类。 一个形状持有自己的顶点数据 (model_vertexes)、索引缓冲区、以及一个控制其在世界中位置，旋转，大小和其它信息的 变换器（transformer）。

- 构建器 (Builder)
> 流式辅助类，让你能通过可读的、可链式调用的方法来构造形状。 ShapeGenerator 类是入口点，它为你提供任何形状类型的全新构建器。

- 变换器 (Transformer)
> 图形对象核心之一。每个形状都拥有一个 DefaultTransformer（或其子类，如 BoxTransformer、CylinderTransformer 等）。它们存储图形的位置，旋转，缩放等重要信息。

- 形状管理器 (ShapeManagers)
> 全局注册表。它根据形状的几何类型（线段、三角形或“空网格”形状，如使用 Minecraft 自身渲染器的文本和方块）将每个形状路由到正确的内部绘制管道

## 问题的本质

在 Minecraft 世界中进行渲染时，几乎所有渲染内容都需要依托某个**对象实例**作为载体。  
例如，实体渲染由实体实例支撑；方块实体渲染由方块实体实例支撑；而流体、地形与天空等内容，则由世界实例支撑。

这些对象实例为渲染系统提供了完整的数据来源与状态控制机制，使运算逻辑能够以一种**与实际渲染过程解耦的方式**被组织和操作。换言之，渲染系统并不直接关心世界的逻辑结构，而是通过对象实例间接获取所需的一切信息；同理，实例不关心自己被如何渲染，其仅仅执行逻辑运算，并向渲染器提供必要的数据。

当开发者需要实现自定义渲染内容时，有时可以**复用现有的对象实例与渲染流程**。  
例如，在渲染苦力怕的爆炸倒计时时，我们可以直接利用苦力怕实例的数据，以及苦力怕渲染器既有的渲染循环：苦力怕实例负责提供位置、爆炸计时器等状态信息，而世界渲染器和苦力怕渲染器则会根据实体位置自动完成模型矩阵的变换，绘制准备等。开发者所需要做的，仅是在原有模型渲染的基础上，额外绘制一段文本即可。

然而，如果开发者需要实现一种**不同于任何现有渲染循环的全新渲染内容**，那么就无法再依赖既有的对象体系。此时，开发者必须自行控制整个过程：包括矩阵的构造与变换、顶点数据的组织方式，以及用于支撑渲染内容的各类必要数据的计算与维护。然而在实际开发中，同时设计对象逻辑与渲染逻辑并非一件容易的事情。

正因如此，本库试图提供一种面向对象的渲染操作抽象框架。  
Shape 实例负责保存实际的空间坐标、顶点等几何数据，而库内的其它模块则根据这些数据完成变换、顶点计算、数据上传与绘制等具体流程，从而实现渲染逻辑与渲染内容之间的解耦。

## Shape对象

> 每一个渲染内容都被视为一个顶点与相关数据的集合，称作“图形”。

## 图形的构成

在本库中，每个形状对象内部维护着这样的数据：

::: file-tree

- Shape.class
  - id   ResourceLocation类，图形的标识符
  - transformer  Transformer类，图形的位置等信息
  - transformFunction  Consumer<Transformer>回调函数，每帧执行的特定逻辑
  - parent  Shape类，可能的父图形
  - children  Shape类列表，可能的子图形
     - …
  - visible  Boolean类，图形逻辑是否被运算
  - baseColor  Color类，图形的基础颜色
  - seeThrough  Boolean类，图形是否穿墙可见
  - modelVertexes  Vec3列表，图形的顶点
  - indexBuffer  整数列表，顶点的连接顺序
  - customData  Object对Object表，图形存储的自定义数据
    - …

:::



